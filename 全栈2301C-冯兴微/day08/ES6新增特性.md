### ES6新增特性

#### 1.let,const

```
let:
1.变量不能重复声明 当前作用域不可以重复声明,在下一个作用域的时候可以重复声明
2.不存在变量提升
3.不影响作用域链

const:
1.声明一个常量,不能更改.声明常量要初始化进行赋值
2.常量用大写
3.块儿级作用域
4.对于数组和对象的元素修改,不算做对常量的修改,不会报错
5.const定义的基本数据类型的变量确实不能修改
```

#### 2.箭头函数

```
- 箭头函数没有this, this指向定义箭头函数所处的外部环境，会捕获所在上下文的this，作为自己的this
- 箭头函数的this永远不会变，call、apply、bind也无法改变
- 箭头函数只能声明匿名函数，但可以通过表达式的方式让箭头函数具名
- 箭头函数没有原型prototype，不能用作为构造函数
- 箭头函数不能当做一个构造函数 因为 this 的指向问题
- 箭头函数没有 arguments  可以使用 ...代替
```

#### 3.展开运算符

```
 3.1 概念：允许一个表达式在某处展开，在多个参数（用于函数调用）或者多个元素（用于数组字面量）或者多个变量（用于解构赋值）的地方就会这样。
 3.2怎么判断是深拷贝还是浅拷贝？
 如果只是一层数组或是对象，其元素只是简单类型的元素，那么属于深拷贝
 如果数组或对象中的元素是引用类型的元素，那么就是浅拷贝
```

#### 4.模版字符串

```

```

#### 5.symbol

```
概念：symbol是一个ES6新增的一种基本数据类型，ymbol 的值是通过 Symbol() 函数生成，每一个 symbol 的值都是唯一的，它主要是为了解决可能出现的全局变量冲突的问题。


```

#### 6.Map

```
6.1 概念和出现的原因:JavaScript 的对象 (Object)，本质上是键值对的集合(Hash 结构)，但是传统上只能用字符串当作键。这给它的使用带来了很大的限制。为了解决这个问题，ES6 提供了 Map 数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值(包括对象都可以当作键。也就是说，Obiect 结构提供了“字符串一值”的对应，Map 结构提供了“值-值”的对应，是一种更完善的 Hash 结构实现。如果你需要“键值对”的数据结构，Map 比 Object 更合适。

6.2 map的方法使用
1.使用new Map0
2.判断长度: map.size
3.添加元素: map.set0
4.获取键值: map.get
5.判断当前对象存不存在该属性: map.has
6.删除当前对象中的属性: map.delete
清空该方法的所有成员:map.clear
```

#### 7.Set

```
7.1 概念: ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值.
本质: 是一个构造函数

7.2 set的实例遍历操作
Set.prototype.keys): 返回键名的遍历器
Set.prototype.values(): 返回键值的遍历器
Set.prototype.entries): 返回键值对的遍历器
Set.prototype.forEachO) : 使用回调函数遍历每个成员

7.3 方法总结
1.获取元素的个数: array.size()
添加元素: array.add().
3.删除元素: array.delete()
检测是否存在这个值: array.has0y4
5，清空: array.clear()
```

#### 8.class

```
ES6 提供了更接近传统语言的写法，引入了 Class(类)这个概念，作为对象的模板。通过 cLass 关键字，可以定义类。基本上，ES6 的 cLass 可以看作只是一个语法糖，新的 Lass 写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。
```

#### 9.promise 和方法

```
1.概念: promise函数是解决异步编程问题产生的,Promise是一个容器，里面保存着某个未来才会结束的事件(通常是个异步操作)的结果。
2.对象的状态有三种状态: pending (进行中)、fulfilled (已成功)和 rejected (已失败)
3..Promise 对象的状态改变只有两种可能: 从 pending 变为 fulfilLed 和从 pending 变为 rejected ,状态改变就不会再变化
4.promise函数底层是根据什么封装的 -- XMLHttpRequest



```

#### 10promise 方法

```
1.promise的all方法 .all同时发起请求，是并发请求
Promise.al方法接受一个数组作为参数，p1、p2、p3都是 Promise 实例，如果不是，就会先调用下面讲到的Promise.resolve方法，将参数转为 Promise 实例，再进一步处理。 (Promise.all方法的参数可以不是数组，但必须具有 terator 接口，且返回的每个成员都是 Promise 实例。

1.2.promise的all特点:
1.接受的参数为数组[]
2.返回值为一个数组,进行获取最终的结果
3.只有参数全部返回成功的时候,才能返回数组,如果一个参数返回失败.全部返回失败

2.promise的race

1.概念:race 竞速 竞跑就是 多个promise同时请求的时候，以第一个请求完成的promise状态 作为整个       promise的状态多个宏任务 执行顺序是 先进先出结束的终点 直到有一个resolve出现

2.2.promise.finally
概念：finally() 方法返回一个 Promise 。在 promise 结束时，结果是 fufiled 或者是 rejected，都会执行指定的回调函数。
```

#### 11.解构赋值

```
它是一种针对数组或者对象进行模式匹配，然后对其中的变量进行赋值。
变量解构赋值：
1.数组解构赋值：不能使用字符串 下标的形式
2.对象解构赋值：使用属性名进行结构 属性名可以重命名
```

